{"version":3,"sources":["index.js","errors/UnauthorizedError.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var jwt = require('jsonwebtoken');\nvar UnauthorizedError = require('./errors/UnauthorizedError');\nvar unless = require('express-unless');\nvar async = require('async');\nvar set = require('lodash.set');\n\nvar DEFAULT_REVOKED_FUNCTION = function(_, __, cb) { return cb(null, false); };\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nfunction wrapStaticSecretInCallback(secret){\n  return function(_, __, cb){\n    return cb(null, secret);\n  };\n}\n\nmodule.exports = function(options) {\n  if (!options || !options.secret) throw new Error('secret should be set');\n\n  var secretCallback = options.secret;\n\n  if (!isFunction(secretCallback)){\n    secretCallback = wrapStaticSecretInCallback(secretCallback);\n  }\n\n  var isRevokedCallback = options.isRevoked || DEFAULT_REVOKED_FUNCTION;\n\n  var _requestProperty = options.userProperty || options.requestProperty || 'user';\n  var _resultProperty = options.resultProperty;\n  var credentialsRequired = typeof options.credentialsRequired === 'undefined' ? true : options.credentialsRequired;\n\n  var middleware = function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          if (credentialsRequired) {\n            return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n          } else {\n            return next();\n          }\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken;\n\n    try {\n      dtoken = jwt.decode(token, { complete: true }) || {};\n    } catch (err) {\n      return next(new UnauthorizedError('invalid_token', err));\n    }\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      if (_resultProperty) {\n        set(res, _resultProperty, result);\n      } else {\n        set(req, _requestProperty, result);\n      }\n      next();\n    });\n  };\n\n  middleware.unless = unless;\n  middleware.UnauthorizedError = UnauthorizedError;\n\n  return middleware;\n};\n\nmodule.exports.UnauthorizedError = UnauthorizedError;\n","function UnauthorizedError (code, error) {\n  this.name = \"UnauthorizedError\";\n  this.message = error.message;\n  Error.call(this, error.message);\n  Error.captureStackTrace(this, this.constructor);\n  this.code = code;\n  this.status = 401;\n  this.inner = error;\n}\n\nUnauthorizedError.prototype = Object.create(Error.prototype);\nUnauthorizedError.prototype.constructor = UnauthorizedError;\n\nmodule.exports = UnauthorizedError;\n"]}